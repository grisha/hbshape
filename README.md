
Status: this is work in progress

This small package allows one to get HarfBuzz positioning data in
Go. This is necessary when rendering text using fonts that take
advantage of the OpenType positioning features.

It appears that as of today, there is no Golang implementation capable
of reading and understanding the GPOS tables, etc, so HarfBuzz is the
only option.

Since HarfBuzz is written in C, building this requires the HarfBuzz
and FreeType development packages (libs and includes).

Here is an example taken from
https://godoc.org/golang.org/x/image/font/sfnt and modified to render
a tall Slavonic letter with an Acute Accent and apply the X and Y
offsets which HarfBuzz provides. Without the offset the accent ends up
being rendered in the middle of the letter (i.e. too low).

``` go
package main

import (
	"image"
	"image/draw"
	"io/ioutil"
	"log"
	"net/http"
	"os"

	"github.com/grisha/hbshape"
	"golang.org/x/image/font"
	"golang.org/x/image/font/sfnt"
	"golang.org/x/image/math/fixed"
	"golang.org/x/image/vector"
)

const (
	ppem   = 32
	width  = 48
	height = 40
)

func main() {

	resp, err := http.Get("https://www.ponomar.net/files/PonomarUnicode.ttf")
	if err != nil {
		log.Fatalf("Get: %v", err)
	}

	fontBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("Read: %v", err)
	}

	f, err := sfnt.Parse(fontBytes)
	if err != nil {
		log.Fatalf("Parse: %v", err)
	}

	r := vector.NewRasterizer(width, height)
	r.DrawOp = draw.Src

	originX := float32(12)
	originY := float32(35)

	shaper, err := hbshape.NewShaper(fontBytes, ppem)
	if err != nil {
		log.Fatalf("NewShaper: %v", err)
	}

	text := "ꙋ́"
	pos, err := shaper.ShapeText(text)
	if err != nil {
		log.Fatalf("ShapeText: %v", err)
	}

	for i, letter := range []rune(text) {

		var b sfnt.Buffer

		x, err := f.GlyphIndex(&b, letter)
		if err != nil {
			log.Fatalf("GlyphIndex: %v", err)
		}
		if x == 0 {
			log.Fatalf("GlyphIndex: no glyph index found for the rune")
		}
		segments, err := f.LoadGlyph(&b, x, fixed.I(ppem), nil)
		if err != nil {
			log.Fatalf("LoadGlyph: %v", err)
		}

		// Apply Harfbuzz offsets
		originY += -float32(pos[i].YOffset)
		originX += float32(pos[i].XOffset)

		for _, seg := range segments {
			// The divisions by 64 below is because the seg.Args values have type
			// fixed.Int26_6, a 26.6 fixed point number, and 1<<6 == 64.
			switch seg.Op {
			case sfnt.SegmentOpMoveTo:
				r.MoveTo(
					originX+float32(seg.Args[0].X)/64,
					originY+float32(seg.Args[0].Y)/64,
				)
			case sfnt.SegmentOpLineTo:
				r.LineTo(
					originX+float32(seg.Args[0].X)/64,
					originY+float32(seg.Args[0].Y)/64,
				)
			case sfnt.SegmentOpQuadTo:
				r.QuadTo(
					originX+float32(seg.Args[0].X)/64,
					originY+float32(seg.Args[0].Y)/64,
					originX+float32(seg.Args[1].X)/64,
					originY+float32(seg.Args[1].Y)/64,
				)
			case sfnt.SegmentOpCubeTo:
				r.CubeTo(
					originX+float32(seg.Args[0].X)/64,
					originY+float32(seg.Args[0].Y)/64,
					originX+float32(seg.Args[1].X)/64,
					originY+float32(seg.Args[1].Y)/64,
					originX+float32(seg.Args[2].X)/64,
					originY+float32(seg.Args[2].Y)/64,
				)
			}
		}
		adv, _ := f.GlyphAdvance(&b, x, fixed.I(ppem), font.HintingFull)
		originX, originY = originX+float32(adv.Floor()), originY

	}
	dst := image.NewAlpha(image.Rect(0, 0, width, height))
	r.Draw(dst, dst.Bounds(), image.Opaque, image.Point{})

	const asciiArt = ".++8"
	buf := make([]byte, 0, height*(width+1))
	for y := 0; y < height; y++ {
		for x := 0; x < width; x++ {
			a := dst.AlphaAt(x, y).A
			buf = append(buf, asciiArt[a>>6])
		}
		buf = append(buf, '\n')
	}
	os.Stdout.Write(buf)
}

```

Will produce the following output:

``` txt
................................................
.......................++.......................
......................+88.......................
......................88........................
.....................+8+...+++..................
.....................8+...8888..................
....................88...8+88+..................
...................+8...8..88+..................
...................++......88...................
................++........+8+...................
..............+8+.........+8....................
............+88+..........8+....................
............888+.........+8.....................
............888+.........88.....................
............+888.........8......................
............+888+.......++......................
.............8888.......8.......................
..............888+.....++.......................
..............+888....+8........................
...............8888...8.........................
...............+888+.8+.........................
................8888++..........................
.................8888...........................
.................+888+..........................
..................8888+.........................
.................8+8888.........................
................++.+888+........................
...............++...8888........................
...............8....+888+.......................
..............+......+888.......................
..............8......+888.......................
..............8......+88+.......................
..............8......+88+.......................
..............+8.....888........................
...............+++++88+.........................
................................................
................................................
................................................
................................................
................................................

```

Without the offsets, the output would look like this:

``` txt
................................................
................................................
................................................
................................................
...........................+++..................
..........................8888..................
.........................8+88+..................
........................8..88+..................
...........................88...................
................++........+8+...................
..............+8+......++.+8....................
............+88+......+88.8+....................
............888+......88++8.....................
............888+.....+8+.88.....................
............+888.....88..8......................
............+888+...+8..++......................
.............8888...8+..8.......................
..............888+.++..++.......................
..............+888....+8........................
...............8888...8.........................
...............+888+.8+.........................
................8888++..........................
.................8888...........................
.................+888+..........................
..................8888+.........................
.................8+8888.........................
................++.+888+........................
...............++...8888........................
...............8....+888+.......................
..............+......+888.......................
..............8......+888.......................
..............8......+88+.......................
..............8......+88+.......................
..............+8.....888........................
...............+++++88+.........................
................................................
................................................
................................................
................................................
................................................

```
